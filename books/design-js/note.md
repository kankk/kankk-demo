# 单例模式
* 定义: 保证一个类仅有一个实例, 并提供一个访问它的全局访问点
* 核心: 确保只有一个实例, 并提供全局访问
* 惰性单例指的是在需要的时候才创建对象实例

# 策略模式
* 策略模式的目的是将算法的使用与算法的实现分离出来
* 策略类: 封装了具体的算法, 并负责具体的计算过程
* 环境类: Context接受客户的请求, 随后把请求委托给某一个策略类

# 代理模式
* 为一个对象提供一个代用品或占位符, 以便控制对它的访问

# 迭代器模式
* 指的是一种方法顺序访问一个聚合对象中的各个元素, 而又不需要暴露该对象的内部表示

# 发布-订阅模式
* 定义对象间一种一对多的依赖关系, 当一个对象的状态发生改变时, 所有依赖于它的对象都将得到通知
* 可以广泛应用于异步编程中, 是一种替代传递回调函数的方案
* 可以取代对象之间硬编码的通知机制, 一个对象不用再显式地调用另外一个对象的某个接口

# 命令模式
* 命令指的是一个执行某些特定事情的指令
* 最常用场景: 有时候需要向某些对象发送请求, 但是并不知道请求的接收者是谁, 也不知道被请求的操作时什么, 此时可以用命令模式

# 组合模式
* 将对象组合成树形结构, 以表示'部分-整体'的层次结构
* 优点: 可以一致地对待组合对象和基本对象
* 注意点
  * 组合模式不是父子关系, 而是一种聚合关系(HAS-A)
  * 对叶子对象操作的一致性, 组合对象和叶子对象要拥有相同接口, 同时对一组叶子对象的操作必须具有一致性
  * 双向映射关系
  * 用职责链模式提高组合模式性能

# 模板方法模式
* 一种只需使用继承就可以实现的模式
* 两部分结构组成, 第一部分是抽象父类, 第二部分是具体的实现子类
* 子类实现中的相同部分被上移到父类中, 而将不同的部分留待子类来实现

# 享元模式
* 核心是运用共享技术来有效支持大量细粒度的对象
* 如果系统中因为创建了大量类似的对象而导致内存占用过高, 享元模式就非常有用
* 要求将对象的属性划分为内部状态与外部状态(状态在这里通常指属性)
* 指引
  * 内部状态存储于对象内部
  * 内部状态可以被一些对象共享
  * 内部状态独立于具体的场景, 通常不会改变
  * 外部状态取决于具体的场景, 并根据场景而变化, 外部状态不能被共享
* 关键是如何区别内部状态和外部状态

# 职责链模式
* 使多个对象都有机会处理请求, 从而避免请求的发送者和接收者之间的耦合关系, 将这些对象练成一条链, 并沿着这条链, 并沿着这条链传递该请求, 直到有一个对象处理它为止
* 可以手动指定起始节点, 请求并不是非得从链中的第一个节点开始传递

# 中介者模式
* 解除对象与对象之间的紧耦合关系
* 增加一个中介者对象后, 所有的相关对象都通过中介者对象来通信, 而不是互相作用, 所以当一个对象发生改变时, 只需要通知中介者对象即可
* 缺点: 系统总会新增一个中介者对象, 因为对象之间交互的复杂性, 转移成了中介者对象的复杂性, 变得难以维护

# 状态模式
* 关键是区分事物内部的状态, 事物内部状态的改变往往会带来事物的行为改变
* 优点:
  * 状态模式定义了状态与行为之间的关系, 并将它们封装在一个类里. 通过增加新的状态类, 很容易增加新的状态和转换
  * 避免Context无限膨胀, 状态切换的逻辑被分布在状态中, 也去掉了Context中原本过多的条件分支
  * 用对象代替字符串来记录当前状态, 使得状态的切换更加一目了然
  * Context中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响
* 缺点: 会在系统中定义许多状态类

# 装饰者模式
* 可以动态地给某个对象添加一些额外的职责, 而不会影响从这个类中派生的其他对象
* 代理模式和装饰者模式最重要的区别在于它们的意图和设计目的. 代理模式的目的是, 当直接访问本体不方便或者不符合需要时, 为这个本体提供一个替代者, 本体定义了关键功能, 而代理提供或拒绝对它的访问, 或者在访问本体之前做一些额外的事情; 装饰者模式就是为对象动态加入行为

# 设计原则和编程技巧
## 单一职责原则
单一职责原则(SRP): 一个对象(方法)只做一件事情
* 代理模式
* 迭代器模式
* 单例模式
* 装饰者模式
优点: 降低了单个类或者对象的复杂度, 按照职责吧对象分解成更小的粒度, 有助于代码的复用, 也有利于进行单元测试.  
缺点: 增加编写代码的复杂度, 也增大了这些对象之间相互联系的难度.

## 最少知识原则
最少知识原则(LKP): 软件实体应该尽可能少地与其他实体发生相互作用
* 中介者模式
* 外观模式

## 开放-封闭原则
开放-封闭原则(OCP): 软件实体等应该是可以扩展的, 但是不可修改
* 发布-订阅模式
* 模板方法模式
* 策略模式
* 代理模式
* 职责链模式